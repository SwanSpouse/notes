### golang 逃逸分析

#### 逃逸分析：

逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。 当一个变量\(或对象\)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。

#### 逃逸分析的作用

* 最大的好处应该是减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。

* 因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好。

* 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。

go在一定程度消除了堆和栈的区别，因为go在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。

#### 参考

* [https://studygolang.com/articles/10026](https://studygolang.com/articles/10026)

* Go 逃逸分析的缺陷: [https://studygolang.com/articles/12396?fr=sidebar](https://studygolang.com/articles/12396?fr=sidebar)

* [https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html)



