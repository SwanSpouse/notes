### Golang 线程模型

#### g0和m0

runtime system中每个M都会拥有一个特殊的Gorountine--g0。它不是由Go程序中的代码（go语句）间接生成的，而是runtime system在初始化M期间创建并分配给M的。g0内含了各种调度、垃圾回收和栈管理等程序。

除了g0之外，其他由M运行的G都可以被视作用户级别的G。用户级别的G可以被简称为用户G，而g0则可以被称为系统G。在通常情况下，M会运行用户G。不过，g0也会时不时地被切换和运行以执行前面说到的那些管理性质的任务。这就是每个M都会运行调度程序的根本原因。与用户G不同，g0不会被阻塞，也不会被包含在任何特殊的G队列或者列表中。同时，它的栈也不会在垃圾回收期间被扫描。

除了每个M都有属于自己的g0之外，还存在一个runtime.g0。runtime.g0被用于执行引导程序。它是在Go程序所间接拥有的第一个内核线程中被运行的。这个内核线程也被成为runtime.m0。runtime.m0和runtime.g0都是被静态分配的，因此引导程序也无需为它们分配内存。

#### 调度器跟踪

系统监测器可以在必要的时候打印出调度器的跟踪信息。我们可以通过设置GODEBUG来对此进行控制。

`export GODEBUG=schedtrace=2000,scheddetail=1`

环境变量GODEBUG的值可以由若干个键值对组成。

schedtrace的值为X的时候，就意味着系统监视器会每X毫秒打印一个单行信息到操作系统的错误输出上。包含了调度器状态的概要。

scheddetail的值为1的时候，那么系统监测器会在上述信息的基础上多打印一行信息，其中包括了调度器以及所有的现存的M、P和G的状态。

